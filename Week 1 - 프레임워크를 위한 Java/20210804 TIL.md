___
# ✍ 20210804 TIL

> ## ✨ Issue
> - 강의를 이해하기에 기본기가 부족하여 기초 강의를 따로 듣고왔다.  
> [JAVA 기초 학습 정리](https://github.com/cse0518/TIL/blob/main/JAVA/JAVA%20%EA%B8%B0%EC%B4%88%20%ED%95%99%EC%8A%B5.md)
> 
> ## ☕ 회고
> - Interface를 아직 활용하기가 어렵다. 연습 필요.
> - 의존성 주입, 의존성 역전 등 추가 학습 필요

## Interface
- 구현이 되어있지 않고 implements 해서 쓸 때 구현이 강제됨
- 다형성 제공
  
  <details>
  <summary> 다형성 예시</summary>
  <div>

  ```java
  public interface Login {
      void login();
  }
  ```
  ```java
  class KakaoLogin implements Login {
      @Override
      public void login() {
          System.out.println("카카오 로그인");
      }
  }

  class NaverLogin implements Login {
      @Override
      public void login() {
          System.out.println("네이버 로그인");
      }
  }

  public class Main {
      public static void main(String[] args) {
          KakaoLogin user1 = new KakaoLogin();
          user1.login(); // 일반적인 카카오 로그인

          NaverLogin user2 = new NaverLogin();
          user1.login(); // 일반적인 네이버 로그인

          // 다형성
          Login user1 = new KakaoLogin(); // Login 인터페이스의 KakaoLogin만 사용
          Login user2 = new NaverLogin(); // Login 인터페이스의 NaverLogin만 사용
      }
  }
  ```

  <br>

  - 로그인 객체 생성하는 메소드를 따로 뺀다.
  ```java
  public class Main {
      public static void main(String[] args) {
          // getLogin 메소드로 생성할 객체를 받아옴.
          Login user = getLogin();
          user.login();
      }

      private static Login getLogin() {
          return new KakaoLogin(); // or NaverLogin();
      }
  }
  ```

  <br>

  - enum 클래스 생성 (LoginType을 parameter로)
    - Factory Pattern
  
  ```java
  public enum LoginType {
      Kakao, Naver
  }
  ```
  ```java
  public class Main {
      public static void main(String[] args) {
          // LoginType 지정 가능.
          Login user = getLogin(LoginType.Kakao);
          user.login();
      }

      // Factory Pattern - LoginType에 따라 로그인 방식 결정
      private static Login getLogin(LoginType type) {
          if(type == LoginType.Kakao) return new KakaoLogin();
          return new NaverLogin();
      }
  }
  ```

  <br>

  - Login 기능을 따로 인스턴스 메소드로 생성
  
  ```java
  public class Main {
      public static void main(String[] args) {
          // 설정 파일을 불러오고 읽어서 Naver, Kakao만 지정 가능
          new Main().run(LoginType.Naver);
      }

      // LoginType 지정 가능.
      void run(LoginType loginType) {
          Login user = getLogin(loginType);
          user.login();
      }

      // Factory Pattern
      private static Login getLogin(LoginType type) {
          if(type == LoginType.Kakao) return new KakaoLogin();
          return new NaverLogin();
      }
  }
  ```

  </div>
  </details>

<br>

- 결합도 낮춤(의존성 역전)

  <details>
  <summary>의존성 역전 예시</summary>
  <div>

  - Login에 의존하는 UserService 클래스를 생성
  
  ```java
  public class UserService implements Login {
      private Login login;

      public UserService(Login login) {
          this.login = login;
      }

      @Override
      public void login() {
          login.login();
      }
  }
  ```
  ```java
  public class Main {
      public static void main(String[] args) {
          UserService us = new UserService(new KakaoLogin());
          us.login();
      }
  }
  ```

  </div>
  </details>

<br>

- 내가 이해한 의존성 역전
![image](https://user-images.githubusercontent.com/60170616/128666546-7290f70f-6909-4521-b647-9c2d366871d2.png)
![image](https://user-images.githubusercontent.com/60170616/128666578-8cd9249e-ef55-4b72-9319-ba2ee30e40c5.png)
  - User Service에서 각각의 Login에 직접 연결되기보다, 중간에 Login Interface를 놓는다면 의존도가 낮아진다.
  - User Service와 각각의 (Kakao, Naver) Login은 결합도가 낮아진다.
  - 의존성 주입: Dependency Injection (DI)
    - Login Interface는 의존성을 주입받았다.
  - 의존성 역전: Dependency Inversion
    - 의존을 하게될 때, 구상체에 의존하지 말고 추상체를 통해서 의존해라.
    - User Service -> Login  
      Login <- Kakao, Naver Login  
      의존의 방향이 다르다 (역전)

  > User Service가 바로 Kakao, Naver Login에 연결된다면,  
  > 새로운 로그인(ex. Google Login)이 추가될 때 User Service에 영향이 갈 수 있을것이다.  
  > 하지만 중간에 Login Interface를 통해서 제어가 된다면,  
  > User Service는 별 지장 없이 서비스를 계속할 수 있을것이다.  
  > (중간에 Gateway, server를 놓는 느낌으로 받아들였다.)
##

## 